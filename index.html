<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tram Nightmare: Dark Watchers</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nosifer&family=Roboto+Mono:wght@400;700&display=swap');

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Roboto Mono', monospace; touch-action: none; user-select: none; }
        
        /* Виньетка (Тьма) */
        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.6) 90%);
            pointer-events: none; z-index: 5;
            transition: background 2s ease-in-out;
        }
        #vignette.darkness {
            background: radial-gradient(circle, rgba(0,0,0,0.2) 20%, rgba(0,0,0,1) 80%);
        }

        /* UI СЛОИ */
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 10; }
        .active { display: flex; }

        /* МЕНЮ */
        #start-screen { 
            background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,1)), url('https://images.unsplash.com/photo-1518531933037-9a847e0f3886?q=80&w=2787&auto=format&fit=crop') center/cover;
            color: #d1d1d1;
        }

        h1 { font-family: 'Nosifer', cursive; font-size: 40px; color: #cc0000; margin: 0 0 20px 0; text-shadow: 0 0 10px #000; text-align: center; letter-spacing: 2px; }
        
        .menu-btn {
            padding: 15px 60px; font-size: 22px; font-family: 'Nosifer', cursive;
            color: #fff; background: #220000; border: 2px solid #550000;
            cursor: pointer; transition: 0.3s; box-shadow: 0 0 15px rgba(255, 0, 0, 0.2);
            text-transform: uppercase; text-align: center; margin-bottom: 10px;
        }
        .menu-btn:hover { background: #440000; transform: scale(1.05); }

        .warning-text { position: absolute; bottom: 30px; font-size: 12px; color: #777; text-align: center; width: 90%; }

        /* ИГРА */
        #game-ui { pointer-events: none; justify-content: flex-start; align-items: flex-start; padding: 0; width: 100%; height: 100%; }
        
        #dist-box {
            font-size: 24px; color: #fff; font-weight: bold; text-shadow: 2px 2px 0 #000;
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 20;
        }

        #boss-warning {
            position: absolute; top: 15%; width: 100%; text-align: center;
            color: #ff0000; font-family: 'Nosifer', cursive; font-size: 40px; display: none;
            animation: pulse 0.15s infinite alternate; text-shadow: 0 0 30px red; z-index: 15;
        }
        @keyframes pulse { from { opacity: 0.2; transform: scale(0.9); } to { opacity: 1; transform: scale(1.1); } }

        /* КНОПКИ */
        .hud-btn {
            pointer-events: auto; position: absolute; width: 50px; height: 50px;
            background: rgba(50, 0, 0, 0.6); border: 2px solid #880000; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; cursor: pointer; z-index: 30; font-family: 'Roboto Mono'; font-weight: bold;
        }
        #pause-btn { top: 20px; right: 20px; font-size: 20px; }
        #cam-btn { top: 80px; right: 20px; font-size: 12px; }

        /* ПАУЗА И ТАЙМЕР */
        #pause-screen { background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); z-index: 40; }
        #countdown-screen { background: rgba(0,0,0,0.3); z-index: 50; }
        #countdown-text { font-family: 'Nosifer'; font-size: 100px; color: #fff; text-shadow: 0 0 20px #fff; }

        /* КОНЕЦ ИГРЫ */
        #game-over { background: rgba(20, 0, 0, 0.95); z-index: 60; }
    </style>
</head>
<body>
    
    <div id="vignette"></div>

    <audio id="bg-music" loop>
        <source src="Sateliti_-_Crna_dvojka_(SkySound.cc).mp3" type="audio/mpeg">
    </audio>
    <video id="boss-video" playsinline loop style="display:none" crossorigin="anonymous" muted>
        <source src="1000018921.mp4" type="video/mp4">
    </video>

    <div id="start-screen" class="screen active">
        <h1>TRAM NIGHTMARE</h1>
        <div class="menu-btn" onclick="startGame()">НАЧАТЬ ПУТЬ</div>
        <div class="warning-text">СВАЙП ДЛЯ ПОВОРОТА | КНОПКА CAM ДЛЯ ВИДА ИЗ КАБИНЫ</div>
    </div>

    <div id="game-ui" class="screen" style="display: none;">
        <div id="dist-box">0 m</div>
        <div id="boss-warning">ДРУН!</div>
        <div id="pause-btn" class="hud-btn" onclick="togglePause()">II</div>
        <div id="cam-btn" class="hud-btn" onclick="toggleCamera()">CAM</div>
    </div>

    <div id="pause-screen" class="screen">
        <h1 style="color: #fff;">ПАУЗА</h1>
        <div class="menu-btn" onclick="resumeGame()">ПРОДОЛЖИТЬ</div>
        <div class="menu-btn" style="font-size: 18px; background: #333;" onclick="toMenu()">В МЕНЮ</div>
    </div>

    <div id="countdown-screen" class="screen">
        <div id="countdown-text">3</div>
    </div>

    <div id="game-over" class="screen">
        <h1 style="color: darkred; font-size: 50px;">МЕРТВ</h1>
        <p id="final-score" style="font-size: 20px; color: #aaa; margin-bottom: 30px;">0 m</p>
        <div class="menu-btn" onclick="resetGame()">ЗАНОВО</div>
        <div class="menu-btn" style="font-size: 18px; padding: 15px 40px; background: #333;" onclick="toMenu()">ВЫХОД</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/** --- НАСТРОЙКИ --- **/
const CONFIG = {
    LANES: [-3.5, 0, 3.5], 
    SPEED: 0.35,            
    BOSS_MILESTONE: 1000,    
    RED_RAIL_TRIGGER: 150,   
    FOG_DENSITY: 0.012, // Уменьшена плотность (было 0.025) для лучшей видимости
    SPAWN_DELAY: 1100       
};

let state = {
    screen: 'MENU', 
    lane: 1,
    distance: 0,
    isPaused: false,
    bossActive: false,
    extraLane: false,
    extraLaneSide: 1,
    animationId: null,
    cameraMode: 'TPS'
};

const music = document.getElementById('bg-music');
const vignette = document.getElementById('vignette');

/** --- СЦЕНА --- **/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020202);
// Туман стал слабее
scene.fog = new THREE.FogExp2(0x020202, CONFIG.FOG_DENSITY);

// Увеличена дальность прорисовки (500)
const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 500);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0x404040, 0.4); 
scene.add(ambientLight);

const moonLight = new THREE.DirectionalLight(0x334455, 0.4);
moonLight.position.set(10, 40, -10);
moonLight.castShadow = true;
scene.add(moonLight);

const tramSpot = new THREE.SpotLight(0xffaa77, 5, 120, 0.6, 0.4, 1);
tramSpot.castShadow = true;

/** --- МОДЕЛИ --- **/
const tramGroup = new THREE.Group();
const cabinGroup = new THREE.Group();

function buildTram() {
    tramGroup.clear();
    cabinGroup.clear();
    
    // МАТЕРИАЛЫ
    const blueMat = new THREE.MeshStandardMaterial({ color: 0x5D9CEC, roughness: 0.7 }); 
    const yellowMat = new THREE.MeshStandardMaterial({ color: 0xFFCE00, roughness: 0.7 }); 
    const redMat = new THREE.MeshStandardMaterial({ color: 0xCC0000, roughness: 0.5 }); 
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
    const woodMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.8 });
    
    // --- КОРПУС ТРАМВАЯ ---
    const chassis = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.6, 8.5), darkMat);
    chassis.position.y = 0.3;
    tramGroup.add(chassis);

    const mainBody = new THREE.Mesh(new THREE.BoxGeometry(2.9, 1.2, 8.4), yellowMat);
    mainBody.position.y = 1.8;
    tramGroup.add(mainBody);

    const bottomSkirt = new THREE.Mesh(new THREE.BoxGeometry(2.9, 0.8, 8.4), blueMat);
    bottomSkirt.position.y = 0.9;
    tramGroup.add(bottomSkirt);

    const stripe = new THREE.Mesh(new THREE.BoxGeometry(2.92, 0.15, 8.42), redMat);
    stripe.position.y = 1.35;
    tramGroup.add(stripe);

    const glassMat = new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.1, transparent: true, opacity: 0.7});
    const cabinGlass = new THREE.Mesh(new THREE.BoxGeometry(2.7, 1.0, 8.0), glassMat);
    cabinGlass.position.y = 2.0;
    tramGroup.add(cabinGlass);

    const roof = new THREE.Mesh(new THREE.BoxGeometry(2.9, 0.2, 8.4), new THREE.MeshStandardMaterial({color: 0xdddddd}));
    roof.position.y = 2.7;
    tramGroup.add(roof);

    tramSpot.position.set(0, 2.5, -3.8);
    tramSpot.target.position.set(0, 0, -30);
    tramGroup.add(tramSpot);
    tramGroup.add(tramSpot.target);

    const pantoBase = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.2, 1.5), darkMat);
    pantoBase.position.set(0, 2.8, 0);
    const pBar = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2), darkMat);
    pBar.position.set(0, 3.5, 0);
    pBar.rotation.z = Math.PI/4;
    tramGroup.add(pantoBase, pBar);

    // ИНТЕРЬЕР
    const dashBox = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 0.6), new THREE.MeshStandardMaterial({color: 0x1a1a1a}));
    dashBox.position.set(-0.7, 1.2, -3.6);
    cabinGroup.add(dashBox);

    const controller = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.4), new THREE.MeshStandardMaterial({color: 0x111}));
    controller.rotation.x = 0.5;
    controller.position.set(-0.7, 1.7, -3.6);
    cabinGroup.add(controller);

    const wheelStand = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.8), darkMat);
    wheelStand.position.set(0.7, 1.0, -3.5);
    cabinGroup.add(wheelStand);

    const wheelTorus = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.04, 8, 16), new THREE.MeshStandardMaterial({color: 0xaa0000}));
    wheelTorus.position.set(0.7, 1.5, -3.5);
    wheelTorus.rotation.x = Math.PI/2 - 0.4;
    cabinGroup.add(wheelTorus);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(3, 2), woodMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.set(0, 0.5, -3.5);
    cabinGroup.add(floor);

    tramGroup.add(cabinGroup);
    scene.add(tramGroup);
}

// ПАУК (МАССИВНЫЙ)
function createMeatySpider() {
    const group = new THREE.Group();
    const blackChitin = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.3, metalness: 0.4 });
    
    // Тело - теперь более жирное и округлое
    const abdomen = new THREE.Mesh(new THREE.SphereGeometry(1.5, 12, 12), blackChitin);
    abdomen.position.z = 1.4;
    abdomen.scale.set(1.1, 0.9, 1.3);
    
    const thorax = new THREE.Mesh(new THREE.SphereGeometry(1.0, 10, 10), blackChitin);
    thorax.position.z = -0.3;
    
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 8, 8), blackChitin);
    head.position.z = -1.2;

    group.add(abdomen, thorax, head);

    // Глаза
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    [[-0.25,-1.1], [0.25,-1.1], [-0.5,-1.0], [0.5,-1.0]].forEach(pos => {
        const e = new THREE.Mesh(new THREE.SphereGeometry(0.12), eyeMat);
        e.position.set(pos[0], 0.4, pos[1]);
        group.add(e);
    });

    // Ноги (МАССИВНЫЕ)
    for(let i=0; i<8; i++) {
        const legGroup = new THREE.Group();
        const side = i < 4 ? 1 : -1;
        const zOffset = ((i % 4) * 0.7) - 0.8;

        // Бедро (толще)
        const femur = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 1.8), blackChitin);
        femur.position.set(side * 0.8, 0.6, 0);
        femur.rotation.z = side * -0.6;
        
        // Голень (толще)
        const tibia = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 2.4), blackChitin);
        tibia.position.set(side * 2.0, -0.4, 0);
        tibia.rotation.z = side * 1.0;

        legGroup.add(femur, tibia);
        legGroup.position.set(0, 0, zOffset);
        legGroup.name = 'leg';
        group.add(legGroup);
    }
    
    // Общий масштаб монстра увеличен
    group.scale.set(1.6, 1.6, 1.6);
    group.rotation.y = Math.PI; 
    return group;
}

function createRuinedHouse() {
    const group = new THREE.Group();
    const wallMat = new THREE.MeshStandardMaterial({color: 0x151515, roughness: 1.0}); 
    const webMat = new THREE.MeshBasicMaterial({color: 0xaaaaaa, wireframe: true, transparent: true, opacity: 0.3});

    const w = 7 + Math.random()*3;
    const h = 10 + Math.random()*8;
    
    const walls = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), wallMat);
    walls.position.y = h/2;
    walls.rotation.y = (Math.random() - 0.5) * 0.2; 
    group.add(walls);

    const web = new THREE.Mesh(new THREE.IcosahedronGeometry(w/1.5, 1), webMat);
    web.position.y = h/2;
    web.scale.set(1, 1.5, 1);
    group.add(web);

    for(let i=0; i<3; i++) {
         const win = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2.0), new THREE.MeshBasicMaterial({color: 0x000000}));
         win.position.set(0, 3 + i*4, w/2 + 0.1);
         if(Math.random() > 0.3) group.add(win); 
    }
    return group;
}

function createObstacle() {
    const g = new THREE.Group();
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.5, 1), new THREE.MeshStandardMaterial({color: 0x333333}));
    mesh.position.y = 0.75;
    const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.2), new THREE.MeshStandardMaterial({color: 0x5a3a2a}));
    bar.position.set(0, 1.5, 0);
    bar.rotation.z = Math.PI/2;
    g.add(mesh, bar);
    return g;
}

/** --- ЛОГИКА МИРА --- **/
const segments = [];
const objects = [];
const enemies = [];
const runningSpiders = []; 
const watchers = []; // Массив для глаз в лесу
let extraRail = null;

// Материалы для рельс (переиспользуем для производительности)
const railMetalMat = new THREE.MeshStandardMaterial({ color: 0x888899, roughness: 0.4, metalness: 0.8 });
const sleeperMat = new THREE.MeshStandardMaterial({ color: 0x2a1d15, roughness: 0.9 });
const ballastMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 1 }); // Темный гравий

function createSegment(zPos) {
    const segGroup = new THREE.Group();
    
    // Земля
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 50),
        new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 1 })
    );
    ground.rotation.x = -Math.PI/2;
    segGroup.add(ground);

    // --- РЕАЛИСТИЧНЫЕ РЕЛЬСЫ ---
    CONFIG.LANES.forEach(x => {
        // Насыпь (балласт)
        const ballast = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.2, 50), ballastMat);
        ballast.position.set(x, 0.05, 0);
        segGroup.add(ballast);

        // Шпалы (более частые и похожие на дерево)
        for(let i=0; i<30; i++) {
            const sleeper = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.15, 0.4), sleeperMat);
            // Немного случайный сдвиг для реализма
            const jiggle = (Math.random() - 0.5) * 0.05;
            sleeper.position.set(x, 0.15, (i * 1.66) - 25 + jiggle);
            sleeper.rotation.y = jiggle * 2;
            segGroup.add(sleeper);
        }

        // Сами рельсы (тонкие, металлические, приподнятые)
        const r1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.25, 50), railMetalMat);
        r1.position.set(x - 0.71, 0.3, 0); // Стандартная колея
        
        const r2 = r1.clone();
        r2.position.set(x + 0.71, 0.3, 0);
        
        segGroup.add(r1, r2);
    });

    segGroup.position.z = zPos;
    scene.add(segGroup);
    segments.push(segGroup);

    // ДЕРЕВЬЯ И ГЛАЗА
    for(let i=0; i<30; i++) {
        const xRaw = (Math.random() - 0.5) * 80; 
        const zTree = zPos - 25 + Math.random() * 50;
        
        if (Math.abs(xRaw) < 5.5) continue;

        // Дерево
        const tree = new THREE.Group();
        const h = 3 + Math.random()*4;
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, h), new THREE.MeshStandardMaterial({color: 0x110d00}));
        trunk.position.y = h/2;
        const leaves = new THREE.Mesh(new THREE.ConeGeometry(2.5, 9, 6), new THREE.MeshStandardMaterial({color: 0x051105}));
        leaves.position.y = h + 2;
        tree.add(trunk, leaves);
        tree.position.set(xRaw, 0, zTree);
        scene.add(tree);
        objects.push({mesh: tree});

        // --- КРАСНЫЕ ГЛАЗА (НАБЛЮДАТЕЛИ) ---
        // Шанс 10% на дерево, что там кто-то смотрит
        if(Math.random() < 0.1) {
            const watcherGroup = new THREE.Group();
            const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
            // Светящийся материал
            const eyeM = new THREE.MeshBasicMaterial({ color: 0xff0000 }); 
            
            const e1 = new THREE.Mesh(eyeGeo, eyeM);
            e1.position.set(-0.15, 0, 0);
            const e2 = new THREE.Mesh(eyeGeo, eyeM);
            e2.position.set(0.15, 0, 0);
            
            watcherGroup.add(e1, e2);
            
            // Высота глаз (в кустах или высоко на дереве)
            const eyeH = 1 + Math.random() * 4;
            // Позиция чуть сбоку от дерева
            watcherGroup.position.set(xRaw + (Math.random()-0.5), eyeH, zTree + (Math.random()-0.5));
            
            scene.add(watcherGroup);
            watchers.push(watcherGroup);
        }
    }

    if(Math.random() > 0.6) {
        const h = createRuinedHouse();
        const side = Math.random() > 0.5 ? 1 : -1;
        h.position.set(side * (12 + Math.random()*5), 0, zPos);
        scene.add(h);
        objects.push({mesh: h});
    }
}

function toggleExtraRail(active, side) {
    if(active && !extraRail) {
        state.extraLane = true;
        state.extraLaneSide = side;
        const xPos = side === 1 ? 8 : -8; 
        const g = new THREE.Group();
        
        // Красные шпалы
        const r1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.25, 300), new THREE.MeshBasicMaterial({color: 0xff0000}));
        r1.position.set(xPos-0.7, 0.2, -100);
        const r2 = r1.clone();
        r2.position.set(xPos+0.7, 0.2, -100);
        
        // И редкие шпалы для призрачного пути
        for(let k=0; k<100; k++) {
             const sl = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 0.3), new THREE.MeshBasicMaterial({color: 0x550000}));
             sl.position.set(xPos, 0.1, -250 + k*3);
             g.add(sl);
        }

        g.add(r1, r2);
        extraRail = g;
        extraRail.position.z = tramGroup.position.z - 50; 
        scene.add(extraRail);
    } else if (!active && extraRail) {
        state.extraLane = false;
        scene.remove(extraRail);
        extraRail = null;
        if( (state.extraLaneSide === 1 && state.lane === 3) || 
            (state.extraLaneSide === -1 && state.lane === -1) ) {
            state.lane = side === 1 ? 2 : 0;
        }
    }
}

/** --- ИГРОВОЙ ЦИКЛ --- **/
let lastSpawnTime = 0;

function spawnEnemy() {
    if(state.bossActive || state.isPaused) return;
    if(performance.now() - lastSpawnTime < CONFIG.SPAWN_DELAY) return;

    const spawnType = Math.random();
    const laneIdx = Math.floor(Math.random() * 3);
    let xPos = CONFIG.LANES[laneIdx];
    
    const zPos = tramGroup.position.z - 120; 

    let entity;
    let type;
    if(spawnType < 0.4) { 
        entity = createObstacle();
        type = 'block';
    } else { 
        entity = createMeatySpider();
        type = 'spider';
    }
    entity.position.set(xPos, 0, zPos);
    scene.add(entity);
    enemies.push({ mesh: entity, type: type });
    lastSpawnTime = performance.now();
}

function spawnRunnerSpider() {
    if(Math.random() > 0.02) return;
    
    const s = createMeatySpider();
    s.scale.set(1.2, 1.2, 1.2); // Фоновые тоже большие
    const side = Math.random() > 0.5 ? 1 : -1;
    const startX = side * 40; // Стартуют дальше
    const zPos = tramGroup.position.z - (100 + Math.random()*50);
    
    s.position.set(startX, 0, zPos);
    s.userData = { vx: -side * 0.4 }; 
    scene.add(s);
    runningSpiders.push(s);
}

function spawnBoss() {
    state.bossActive = true;
    const warningEl = document.getElementById('boss-warning');
    warningEl.style.display = 'block';
    vignette.classList.add('darkness');

    const video = document.getElementById('boss-video');
    video.currentTime = 0;
    const geometry = new THREE.PlaneGeometry(14, 20); 
    const texture = new THREE.VideoTexture(video);
    const material = new THREE.MeshBasicMaterial({ map: texture });
    const bossMesh = new THREE.Mesh(geometry, material);
    
    bossMesh.position.set(0, 7, tramGroup.position.z - 180);
    scene.add(bossMesh);
    enemies.push({ mesh: bossMesh, type: 'boss' });
}

function updateCamera() {
    if(state.cameraMode === 'FPS') {
        const targetPos = tramGroup.position.clone();
        targetPos.add(new THREE.Vector3(0, 2.7, -3.2)); 
        camera.position.copy(targetPos);
        const lookAtPos = tramGroup.position.clone().add(new THREE.Vector3(0, 0, -20));
        camera.lookAt(lookAtPos);
    } else {
        const camTargetZ = tramGroup.position.z + 12; 
        const camTargetY = 10; 
        
        camera.position.z += (camTargetZ - camera.position.z) * 0.1;
        camera.position.y += (camTargetY - camera.position.y) * 0.1;
        
        const targetX = tramGroup.position.x * 0.6; 
        camera.position.x += (targetX - camera.position.x) * 0.08;

        camera.lookAt(tramGroup.position.x * 0.3, 0, tramGroup.position.z - 30);
    }
}

function animate() {
    state.animationId = requestAnimationFrame(animate);

    if(state.isPaused) return;
    if(state.screen !== 'GAME') {
        if(state.screen === 'GAME') renderer.render(scene, camera);
        return;
    }

    tramGroup.position.z -= CONFIG.SPEED;
    updateCamera();

    let targetX = 0;
    if(state.lane === -1) targetX = -8;
    else if(state.lane === 3) targetX = 8;
    else targetX = CONFIG.LANES[state.lane];

    tramGroup.position.x += (targetX - tramGroup.position.x) * 0.1;
    tramGroup.rotation.z = (tramGroup.position.x - targetX) * 0.05;
    tramGroup.position.y = Math.sin(tramGroup.position.z * 1.5) > 0.9 ? (Math.random()-0.5)*0.04 : 0;

    // ОБНОВЛЕНИЕ ГЛАЗ (СЛЕЖКА)
    // Оптимизация: обновляем только глаза в радиусе 100 метров
    const tramPos = tramGroup.position;
    for(let i = watchers.length - 1; i >= 0; i--) {
        const w = watchers[i];
        if(w.position.z > tramPos.z + 20) {
            // Удаляем глаза, которые остались позади
            scene.remove(w);
            watchers.splice(i, 1);
        } else if (Math.abs(w.position.z - tramPos.z) < 150) {
            // Глаза поворачиваются к трамваю
            w.lookAt(tramPos.x, tramPos.y + 2, tramPos.z);
        }
    }

    // Враги
    for(let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if(e.type === 'spider') {
            e.mesh.position.z += CONFIG.SPEED * 0.5; 
            e.mesh.children.forEach(c => {
                if(c.name === 'leg') c.rotation.x = Math.sin(Date.now() * 0.02 + c.position.z) * 0.8;
            });
        }

        if(e.type === 'boss') {
            const dist = Math.abs(e.mesh.position.z - tramGroup.position.z);
            if(dist < 80 && document.getElementById('boss-video').paused && !state.isPaused) {
                document.getElementById('boss-video').play().catch(()=>{});
            }
            if(dist < 5) {
                if(state.lane === -1 || state.lane === 3) {  } 
                else { gameOver(); }
            }
            if(e.mesh.position.z > tramGroup.position.z + 20) {
                scene.remove(e.mesh);
                enemies.splice(i, 1);
                state.bossActive = false;
                document.getElementById('boss-warning').style.display = 'none';
                vignette.classList.remove('darkness'); 
                toggleExtraRail(false);
                continue;
            }
        } else {
            const dx = Math.abs(e.mesh.position.x - tramGroup.position.x);
            const dz = Math.abs(e.mesh.position.z - tramGroup.position.z);
            // Из-за увеличения размеров пауков, чуть увеличим хитбокс
            const hitDist = e.type === 'spider' ? 2.5 : 3.0;
            if(dx < 2.0 && dz < hitDist) gameOver();
            if(e.mesh.position.z > tramGroup.position.z + 20) {
                scene.remove(e.mesh);
                enemies.splice(i, 1);
            }
        }
    }

    spawnRunnerSpider();
    for(let i = runningSpiders.length - 1; i >= 0; i--) {
        const s = runningSpiders[i];
        s.position.x += s.userData.vx;
        s.children.forEach(c => { if(c.name === 'leg') c.rotation.x = Math.sin(Date.now() * 0.03) * 1.0; });
        if(Math.abs(s.position.x) > 60 || s.position.z > tramGroup.position.z + 20) {
            scene.remove(s);
            runningSpiders.splice(i, 1);
        }
    }

    // Генерация мира
    const lastSeg = segments[segments.length-1];
    if(lastSeg.position.z > tramGroup.position.z - 300) createSegment(lastSeg.position.z - 50); // Генерируем заранее (было 250)
    if(segments[0].position.z > tramGroup.position.z + 50) {
        scene.remove(segments[0]);
        segments.shift();
    }
    if(objects.length > 0 && objects[0].mesh.position.z > tramGroup.position.z + 50) {
        scene.remove(objects[0].mesh);
        objects.shift();
    }
    
    if(extraRail) extraRail.position.z = tramGroup.position.z - 50;

    spawnEnemy();
    
    const prevDist = Math.floor(state.distance);
    state.distance += CONFIG.SPEED * 0.5;
    const currDist = Math.floor(state.distance);
    document.getElementById('dist-box').innerText = currDist + " m";
    
    const distMod = currDist % CONFIG.BOSS_MILESTONE;
    const nextBoss = (Math.floor(currDist / CONFIG.BOSS_MILESTONE) + 1) * CONFIG.BOSS_MILESTONE;
    const distToNextBoss = nextBoss - currDist;

    if (distToNextBoss <= CONFIG.RED_RAIL_TRIGGER && !state.bossActive && !extraRail) {
        const side = Math.random() > 0.5 ? 1 : -1;
        toggleExtraRail(true, side);
    }

    if(currDist > 0 && distMod === 0 && currDist !== prevDist && !state.bossActive) {
        spawnBoss();
    }

    renderer.render(scene, camera);
}

// --- УПРАВЛЕНИЕ ---

function toggleCamera() {
    state.cameraMode = state.cameraMode === 'TPS' ? 'FPS' : 'TPS';
    const btn = document.getElementById('cam-btn');
    btn.style.borderColor = state.cameraMode === 'FPS' ? '#00ff00' : '#880000';
}

function togglePause() {
    if(state.screen !== 'GAME' || state.screen === 'OVER') return;
    
    if(!state.isPaused) {
        state.isPaused = true;
        document.getElementById('pause-screen').classList.add('active');
        document.getElementById('boss-video').pause();
        music.pause();
    } else {
        resumeGame();
    }
}

function resumeGame() {
    document.getElementById('pause-screen').classList.remove('active');
    document.getElementById('countdown-screen').classList.add('active');
    
    let count = 3;
    const el = document.getElementById('countdown-text');
    el.innerText = count;
    
    const timer = setInterval(() => {
        count--;
        if(count > 0) {
            el.innerText = count;
        } else {
            clearInterval(timer);
            document.getElementById('countdown-screen').classList.remove('active');
            state.isPaused = false;
            music.play();
        }
    }, 1000);
}

document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
        if(state.screen === 'GAME' && !state.isPaused) togglePause();
        music.pause();
    } 
});

function startGame() {
    if(state.animationId) cancelAnimationFrame(state.animationId);

    state.screen = 'GAME';
    document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
    document.getElementById('game-ui').style.display = 'flex';
    
    music.currentTime = 0;
    music.play().catch(e => console.log("Audio req click"));
    vignette.classList.remove('darkness');

    resetWorld();
    animate();
}

function resetWorld() {
    state.lane = 1;
    state.distance = 0;
    state.bossActive = false;
    state.extraLane = false;
    state.isPaused = false;
    tramGroup.position.set(0,0,0);
    
    enemies.forEach(e => scene.remove(e.mesh));
    enemies.length = 0;
    runningSpiders.forEach(s => scene.remove(s));
    runningSpiders.length = 0;
    watchers.forEach(w => scene.remove(w));
    watchers.length = 0;
    
    segments.forEach(s => scene.remove(s));
    segments.length = 0;
    
    objects.forEach(o => scene.remove(o.mesh));
    objects.length = 0;
    
    for(let i=0; i<8; i++) createSegment(i * -50);
}

function gameOver() {
    state.screen = 'OVER';
    document.getElementById('game-over').classList.add('active');
    document.getElementById('game-ui').style.display = 'none';
    document.getElementById('final-score').innerText = Math.floor(state.distance) + " METERS";
    document.getElementById('boss-video').pause();
    music.pause();
    vignette.classList.remove('darkness');
}

function resetGame() {
    document.getElementById('game-over').classList.remove('active');
    startGame();
}

function toMenu() {
    state.screen = 'MENU';
    document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
    document.getElementById('start-screen').classList.add('active');
    document.getElementById('game-ui').style.display = 'none';
    music.pause();
    music.currentTime = 0;
    vignette.classList.remove('darkness');
    if(state.animationId) cancelAnimationFrame(state.animationId);
}

window.addEventListener('keydown', e => {
    if(e.code === 'Space') togglePause();
    if(e.code === 'KeyC') toggleCamera();
    if(state.screen !== 'GAME' || state.isPaused) return;
    
    if(e.key === 'ArrowLeft') {
        if(state.lane > 0) state.lane--;
        else if(state.extraLane && state.extraLaneSide === -1) state.lane = -1;
    }
    if(e.key === 'ArrowRight') {
        if(state.lane < 2) state.lane++;
        else if(state.extraLane && state.extraLaneSide === 1) state.lane = 3;
    }
});

let touchStartX = 0;
window.addEventListener('touchstart', e => touchStartX = e.touches[0].clientX);
window.addEventListener('touchend', e => {
    if(state.screen !== 'GAME' || state.isPaused) return;
    if(e.target.classList.contains('hud-btn')) return;

    const diff = e.changedTouches[0].clientX - touchStartX;
    if(Math.abs(diff) > 30) {
        if(diff > 0) {
             if(state.lane < 2) state.lane++;
             else if(state.extraLane && state.extraLaneSide === 1) state.lane = 3;
        } else {
             if(state.lane > 0) state.lane--;
             else if(state.extraLane && state.extraLaneSide === -1) state.lane = -1;
        }
    }
});

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

buildTram();
createSegment(0);

</script>
</body>
</html>
